# Welcome to Arc

Arc is an open Layer-1 blockchain purpose-built to unite programmable money and
onchain innovation with real-world economic activity. Designed to serve as the
Economic OS for the internet, Arc enables builders and issuers worldwide to
power the next era of onchain lending, capital markets, FX, and payments,
igniting liquidity across currencies and asset classes.

Engineered for mass adoption, Arc is enterprise-grade infrastructure featuring
predictable fiat-based fees using stablecoins as gas (starting with USDC),
deterministic sub-second finality, opt-in configurable privacy, and direct
integration with Circle's full-stack platform for secure access to liquidity and
powerful developer tooling.

As a public EVM-compatible network, developers can deploy smart contracts, build
applications, and transact freely using familiar tools. While validator
participation is permissioned for security and compliance, access to Arc is
fully open.

<Tip>
  Ready to start building? See the [Deploy on Arc](/arc/tutorials/deploy-on-arc)
  quickstart.
</Tip>

## Core principles

Arc is more than a new blockchain. It's a new approach to how global economic
coordination and infrastructure should be built, forged with the same principles
of transparency and trust that define Circle:

<AccordionGroup>
  <Accordion title="Purpose-built, not general-purpose">
    Arc focuses on real-world economic activity, including but not limited to
    global finance, internet commerce, and institutional-grade DeFi.
  </Accordion>

  <Accordion title="Open and composable by default">
    While enterprise-ready, Arc is a public network and open to all developers.
    Anyone can build, transact, integrate, and contribute to the Arc ecosystem.
  </Accordion>

  <Accordion title="Market-neutral and multichain-aligned">
    Arc is interoperable with the broader multichain ecosystem through Circle CCTP
    and Circle Gateway, unlocking new use cases, partners, and institutional
    liquidity onchain.
  </Accordion>

  <Accordion title="Built to coordinate, not control">
    Arc aligns builders and partners across exchanges, market makers, asset
    issuers, fintechs, banks, PSPs, and enterprises to achieve something bigger
    than the sum of their parts.
  </Accordion>

  <Accordion title="Trusted infrastructure, end-to-end">
    Arc is built on Malachite, a highly efficient BFT consensus engine designed
    for certainty, reliability, and long-term operational excellence.
  </Accordion>
</AccordionGroup>

## What you can build

<AccordionGroup>
  <Accordion title="Onchain credit with offchain trust">
    Design credit infrastructure that combines stablecoins with external trust
    signals:

    * **Identity-based lending protocols** using verifiable credentials
    * **Reputation-driven credit systems** tied to cash flow or payment history
    * **SMB and consumer credit apps** serving under-served markets
  </Accordion>

  <Accordion title="Capital markets settlement and tokenized collateral">
    Modernize capital markets with stablecoin-native settlement:

    * **Tokenized securities platforms** with instant DvP
    * **Collateral management systems** for stablecoin-backed margin
    * **Tokenized funds and structured products** issued onchain
    * **Prediction markets** trading real-time data, forecasts, and risk signals
  </Accordion>

  <Accordion title="Stablecoin FX">
    Create markets and services around stablecoin conversion and FX:

    * **Perpetuals and derivatives exchanges** on stablecoin pairs
    * **Swap APIs** for programmatic stablecoin-to-stablecoin conversion
    * **Treasury tools** for multi-currency rebalancing and cross-border payouts
  </Accordion>

  <Accordion title="Agentic commerce">
    Enable autonomous systems to transact natively onchain:

    * **AI-mediated marketplaces** where agents buy, sell, and execute transactions
    * **Machine-to-machine payment networks** for IoT and devices
    * **Coordination systems** for agents to post, match, and settle intents in real
      time
  </Accordion>

  <Accordion title="Cross-border payments and payouts">
    Power global money movement with fiat-backed stablecoins, instant settlement,
    and low fees:

    * **Remittance platforms** for consumer transfers
    * **Payout systems** for marketplaces, gig workers, and global payroll
    * **Trade finance platforms** with tokenized invoices and automated onchain
      settlement
  </Accordion>
</AccordionGroup>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Welcome to Arc

Arc is an open Layer-1 blockchain purpose-built to unite programmable money and
onchain innovation with real-world economic activity. Designed to serve as the
Economic OS for the internet, Arc enables builders and issuers worldwide to
power the next era of onchain lending, capital markets, FX, and payments,
igniting liquidity across currencies and asset classes.

Engineered for mass adoption, Arc is enterprise-grade infrastructure featuring
predictable fiat-based fees using stablecoins as gas (starting with USDC),
deterministic sub-second finality, opt-in configurable privacy, and direct
integration with Circle's full-stack platform for secure access to liquidity and
powerful developer tooling.

As a public EVM-compatible network, developers can deploy smart contracts, build
applications, and transact freely using familiar tools. While validator
participation is permissioned for security and compliance, access to Arc is
fully open.

<Tip>
  Ready to start building? See the [Deploy on Arc](/arc/tutorials/deploy-on-arc)
  quickstart.
</Tip>

## Core principles

Arc is more than a new blockchain. It's a new approach to how global economic
coordination and infrastructure should be built, forged with the same principles
of transparency and trust that define Circle:

<AccordionGroup>
  <Accordion title="Purpose-built, not general-purpose">
    Arc focuses on real-world economic activity, including but not limited to
    global finance, internet commerce, and institutional-grade DeFi.
  </Accordion>

  <Accordion title="Open and composable by default">
    While enterprise-ready, Arc is a public network and open to all developers.
    Anyone can build, transact, integrate, and contribute to the Arc ecosystem.
  </Accordion>

  <Accordion title="Market-neutral and multichain-aligned">
    Arc is interoperable with the broader multichain ecosystem through Circle CCTP
    and Circle Gateway, unlocking new use cases, partners, and institutional
    liquidity onchain.
  </Accordion>

  <Accordion title="Built to coordinate, not control">
    Arc aligns builders and partners across exchanges, market makers, asset
    issuers, fintechs, banks, PSPs, and enterprises to achieve something bigger
    than the sum of their parts.
  </Accordion>

  <Accordion title="Trusted infrastructure, end-to-end">
    Arc is built on Malachite, a highly efficient BFT consensus engine designed
    for certainty, reliability, and long-term operational excellence.
  </Accordion>
</AccordionGroup>

## What you can build

<AccordionGroup>
  <Accordion title="Onchain credit with offchain trust">
    Design credit infrastructure that combines stablecoins with external trust
    signals:

    * **Identity-based lending protocols** using verifiable credentials
    * **Reputation-driven credit systems** tied to cash flow or payment history
    * **SMB and consumer credit apps** serving under-served markets
  </Accordion>

  <Accordion title="Capital markets settlement and tokenized collateral">
    Modernize capital markets with stablecoin-native settlement:

    * **Tokenized securities platforms** with instant DvP
    * **Collateral management systems** for stablecoin-backed margin
    * **Tokenized funds and structured products** issued onchain
    * **Prediction markets** trading real-time data, forecasts, and risk signals
  </Accordion>

  <Accordion title="Stablecoin FX">
    Create markets and services around stablecoin conversion and FX:

    * **Perpetuals and derivatives exchanges** on stablecoin pairs
    * **Swap APIs** for programmatic stablecoin-to-stablecoin conversion
    * **Treasury tools** for multi-currency rebalancing and cross-border payouts
  </Accordion>

  <Accordion title="Agentic commerce">
    Enable autonomous systems to transact natively onchain:

    * **AI-mediated marketplaces** where agents buy, sell, and execute transactions
    * **Machine-to-machine payment networks** for IoT and devices
    * **Coordination systems** for agents to post, match, and settle intents in real
      time
  </Accordion>

  <Accordion title="Cross-border payments and payouts">
    Power global money movement with fiat-backed stablecoins, instant settlement,
    and low fees:

    * **Remittance platforms** for consumer transfers
    * **Payout systems** for marketplaces, gig workers, and global payroll
    * **Trade finance platforms** with tokenized invoices and automated onchain
      settlement
  </Accordion>
</AccordionGroup>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Deploy on Arc

> This tutorial helps you deploy your smart contract on Arc Testnet

<Info>
  Arc is currently in its testnet phase. During this period, the network may
  experience instability or unplanned downtime. **Note:** Throughout this page,
  all references to Arc refer specifically to the Arc Testnet.
</Info>

In this tutorial, you'll use Solidity and Foundry to write, deploy, and interact
with a simple smart contract on the Arc Testnet.

## What you'll learn

By the end of this tutorial, you'll be able to:

* Set up your development environment
* Configure Foundry to connect with Arc
* Implement your smart contract
* Deploy your contract to Arc Testnet
* Interact with your deployed contract

## Set up your development environment

Before you deploy to Arc, you need a working development environment. In this
step, you install [**Foundry**](https://getfoundry.sh/), a portable Ethereum
development toolkit, and initialize a new Solidity project.

1. Install Development Tools

```shell  theme={null}
# Download foundry installer `foundryup`
curl -L https://foundry.paradigm.xyz | bash
```

2. Install binaries

```shell  theme={null}
# Install forge, cast, anvil, chisel
foundryup
```

3. Initialize a new Solidity Project

```shell  theme={null}
forge init hello-arc && cd hello-arc
```

## Configure Foundry to interact with Arc

In this step, you set up Foundry to connect to the Arc network by adding Arc's
RPC URLs to your project environment.

1. Create a `.env` file

Open the `hello-arc` project in your preferred code editor (for example, **VS
Code**). Then, create a new file named `.env` in the root of the project
directory.

2. Add the Arc Testnet RPC URL

Paste the following environment variable into the `.env` file:

```ini  theme={null}
ARC_TESTNET_RPC_URL="https://rpc.testnet.arc.network"
```

This URL allows Foundry to connect to the Arc Testnet.

<Tip>
  Never commit your `.env` file to version control. Store private keys and
  sensitive variables securely.
</Tip>

## Implement your smart contract

In this step, you create the **HelloArchitect** contract, update the test and
script files, and compile the project.

<Info>
  **HelloArchitect** is a simple storage contract that manages a greeting
  message: it starts with a default greeting, lets you update it, and emits an
  event whenever the greeting changes.
</Info>

### 1. Write the HelloArchitect contract

First, delete the default `Counter.sol` template file from the `/src` directory:

```shell  theme={null}
rm src/Counter.sol
```

Next, create a new file named `HelloArchitect.sol` inside the `/src` directory,
and add the following code:

```js  theme={null}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

contract HelloArchitect {
    string private greeting;

    // Event emitted when the greeting is changed
    event GreetingChanged(string newGreeting);

    // Constructor that sets the initial greeting to "Hello Architect!"
    constructor() {
        greeting = "Hello Architect!";
    }

    // Setter function to update the greeting
    function setGreeting(string memory newGreeting) public {
        greeting = newGreeting;
        emit GreetingChanged(newGreeting);
    }

    // Getter function to return the current greeting
    function getGreeting() public view returns (string memory) {
        return greeting;
    }
}
```

This contract includes a private `greeting` variable that stores the greeting
string, along with two public functions:

* `setGreeting` updates the `greeting` value and emits the `GreetingChanged`
  event
* `getGreeting` returns the current value of `greeting`

### 2. Update scripts and tests

Since you deleted `Counter.sol`, you need to remove or replace any scripts and
tests that reference it to avoid compilation errors.

**Delete the `script` directory**

The `script` directory includes files that reference `Counter.sol`. Since you've
removed `Counter.sol`, delete the entire `script` directory to avoid compilation
errors:

```shell  theme={null}
rm -rf script
```

<Tip>
  You can recreate this directory later with updated deployment scripts for your
  own contracts.
</Tip>

**Replace `Counter.t.sol` with `HelloArchitect.t.sol`**

Navigate to the `/test` directory, delete the existing `Counter.t.sol` file, and
create a new test file named `HelloArchitect.t.sol`. Then, add the following
test cases to validate your contract:

```js  theme={null}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/HelloArchitect.sol";

contract HelloArchitectTest is Test {
    HelloArchitect helloArchitect;

    function setUp() public {
        helloArchitect = new HelloArchitect();
    }

    function testInitialGreeting() public view {
        string memory expected = "Hello Architect!";
        string memory actual = helloArchitect.getGreeting();
        assertEq(actual, expected);
    }

    function testSetGreeting() public {
        string memory newGreeting = "Welcome to Arc Chain!";
        helloArchitect.setGreeting(newGreeting);
        string memory actual = helloArchitect.getGreeting();
        assertEq(actual, newGreeting);
    }

    function testGreetingChangedEvent() public {
        string memory newGreeting = "Building on Arc!";

        // Expect the GreetingChanged event to be emitted
        vm.expectEmit(true, true, true, true);
        emit HelloArchitect.GreetingChanged(newGreeting);

        helloArchitect.setGreeting(newGreeting);
    }
}
```

### 3. Test the contract

Run the following command to execute the contract's unit tests locally:

```shell  theme={null}
forge test
```

This will compile the project, run the tests defined in `HelloArchitect.t.sol`,
and display the results in your terminal.

### 4. Compile the contract

To compile the **HelloArchitect** contract and generate build artifacts, run:

```shell  theme={null}
forge build
```

This creates the `/out` directory containing the compiled bytecode and ABI,
which you'll use when deploying the contract.

## Deploy your contract to Arc Testnet

In this step, you generate a wallet, fund it with testnet USDC (Arc's native gas
token), and deploy your smart contract to the Arc Testnet using Foundry.

### 1. Generate a wallet

To deploy the **HelloArchitect** contract, you need a funded wallet. Use the
Foundry command-line tool to generate a new wallet:

```shell  theme={null}
cast wallet new
```

The command generates a new keypair and returns output similar to the following:

```
Successfully created new keypair.
Address:     0xB815A0c4bC23930119324d4359dB65e27A846A2d
Private key: 0xcc1b30a6af68ea9a9917f1dd••••••••••••••••••••••••••••••••••••••97c5
```

<Warning>
  **Important:** Keep your private key secure. Never share it or commit it to
  source control.
</Warning>

Add your private key to your `.env` file:

```ini  theme={null}
PRIVATE_KEY="0x..."
```

Reload your environment variables:

```shell  theme={null}
source .env
```

### 2. Fund your wallet

Visit [https://faucet.circle.com](https://faucet.circle.com), select **Arc Testnet**, paste your wallet
address, and request testnet USDC.

Since USDC is Arc's native gas token, this will provide the funds needed to
cover gas fees when deploying your contract.

<Info>
  Testnet USDC is for testing purposes only. It has no real-world value and must
  not be used in production.
</Info>

### 3. Deploy the contract

With your wallet funded with testnet USDC, deploy the **HelloArchitect**
contract to the Arc Testnet using the Foundry command-line tool:

```shell  theme={null}
forge create src/HelloArchitect.sol:HelloArchitect \
  --rpc-url $ARC_TESTNET_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast
```

<Warning>
  **Important:** Never expose your real private key in production. Use
  environment variables or secrets management in real deployments.
</Warning>

After the contract is deployed successfully, you should see output similar to
this:

```
Compiler run successful!
Deployer: 0xB815A0c4bC23930119324d4359dB65e27A846A2d
Deployed to: 0x32368037b14819C9e5Dbe96b3d67C59b8c65c4BF
Transaction hash: 0xeba0fcb5e528d586db0aeb2465a8fad0299330a9773ca62818a1827560a67346
```

### 4. Store the contract address

Copy the deployed contract address from the `Deployed to:` line and save it to
your `.env` file:

```ini  theme={null}
HELLOARCHITECT_ADDRESS="0x..."
```

Reload your environment variables again:

```shell  theme={null}
source .env
```

## Interact with your deployed contract

In this step, you verify that the deployment succeeded by checking the
transaction in the Arc Testnet Explorer, then use `cast` to call a function from
your contract.

### 1. Check transaction on the explorer

Open the [Arc Testnet Explorer](https://testnet.arcscan.app), and paste the
**transaction hash** from the deployment output. This lets you view the
transaction details and confirm that the contract was deployed successfully.

### 2. Use `cast` to call a contract function

Use the `cast call` command to interact with your deployed contract from the
command line. Run the following:

```shell  theme={null}
cast call $HELLOARCHITECT_ADDRESS "getGreeting()(string)" \
  --rpc-url $ARC_TESTNET_RPC_URL
```

The command calls the `getGreeting` function on the **HelloArchitect** contract
and returns the current value of the `greeting` variable.

## Next steps

Congratulations, you've deployed and interacted with your first contract on Arc
Testnet. From here, you can:

* Extend the **HelloArchitect** contract with more logic for additional
  features.
* Explore Arc's stablecoin-native features like USDC as gas and deterministic
  finality
* Build more advanced applications for payments, FX, or tokenized assets
# Connect to Arc

This page shows how to connect your app and wallet to the Arc blockchain.

## Network details

### Arc Testnet

| Name             | Value                                                                                                                                                                                                                                                                                                                                                                                   |
| :--------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Network**      | Arc Testnet                                                                                                                                                                                                                                                                                                                                                                             |
| **RPC endpoint** | [https://rpc.testnet.arc.network](https://rpc.testnet.arc.network) <br /> Alternatives: <br />   • [https://rpc.blockdaemon.testnet.arc.network](https://rpc.blockdaemon.testnet.arc.network) <br />   • [https://rpc.drpc.testnet.arc.network](https://rpc.drpc.testnet.arc.network) <br />   • [https://rpc.quicknode.testnet.arc.network](https://rpc.quicknode.testnet.arc.network) |
| **WebSocket**    | [wss://rpc.testnet.arc.network](wss://rpc.testnet.arc.network) <br /> Alternatives: <br />   • [wss://rpc.drpc.testnet.arc.network](wss://rpc.drpc.testnet.arc.network) <br />   • [wss://rpc.quicknode.testnet.arc.network](wss://rpc.quicknode.testnet.arc.network)                                                                                                                   |
| **Chain ID**     | 5042002                                                                                                                                                                                                                                                                                                                                                                                 |
| **Currency**     | USDC                                                                                                                                                                                                                                                                                                                                                                                    |
| **Explorer**     | [https://testnet.arcscan.app](https://testnet.arcscan.app)                                                                                                                                                                                                                                                                                                                              |
| **Faucet**       | [https://faucet.circle.com](https://faucet.circle.com)                                                                                                                                                                                                                                                                                                                                  |

## Wallet setup

### Add Arc Testnet

1. Open MetaMask → **Add network** → **Add a network manually**.
2. Fill in:

| Field               | Value                                                              |
| :------------------ | :----------------------------------------------------------------- |
| **Network name**    | Arc Testnet                                                        |
| **New RPC URL**     | [https://rpc.testnet.arc.network](https://rpc.testnet.arc.network) |
| **Chain ID**        | 5042002                                                            |
| **Currency symbol** | USDC                                                               |
| **Explorer URL**    | [https://testnet.arcscan.app](https://testnet.arcscan.app)         |

3. Save, then switch to Arc.

<Tip>
  If your wallet supports **custom gas tokens**, ensure display/decimals for
  USDC (6 decimals) and clearly label fees as USDC.
</Tip>

## Gas and fees

| Key               | Value                                                                       |
| :---------------- | :-------------------------------------------------------------------------- |
| **Unit**          | USDC (6 decimals)                                                           |
| **Pricing**       | EIP-1559-like base fee with exponentially weighted moving average smoothing |
| **Best practice** | Surface fees in USDC, fetch base fee dynamically, set modest priority tip   |

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Contract Addresses

This page lists the official smart contract addresses for stablecoins and
crosschain components on the Arc network.

## Stablecoins

Stablecoins are the foundation of the Arc ecosystem, providing price-stable
digital money for payments, FX, and onchain financial applications. The ERC-20
functions will affect native balance movements.

### USDC

USDC is the native EVM asset on Arc and is used for gas fees. The native
balance, consistent with most EVM implementations, expresses the balance up to
18 decimals of precision.

An optional USDC ERC-20 interface is also available for developers who need
ERC-20 features such as `transferFrom`, `approve`, and allowance management. The
ERC-20 function call directly affects native USDC balance movements.

* **Contract address:**
  [`0x3600000000000000000000000000000000000000`](https://testnet.arcscan.app/address/0x3600000000000000000000000000000000000000)
* **Decimals:** 6
* **Behavior:** Your native USDC balance and the ERC-20 interface balance are
  equivalent. It is not a wrapped token like WETH.

<Info>
  **Note:** As with any ERC-20 token, always use the `decimals()` function to
  interpret balances and transfer amounts accurately. On Arc, the **native USDC
  gas token** uses 18 decimals of precision, while the **USDC ERC-20 interface**
  uses 6 decimals. Avoid mixing these values directly, as doing so may result in
  incorrect balance handling. For applications integrating USDC, it's
  recommended to rely solely on the standard ERC-20 interface for reading
  balances and sending transfers.
</Info>

### EURC

EURC is the euro-denominated stablecoin issued by Circle and supported natively
on Arc for use in payments, FX, and other financial applications.

* **Contract address:**
  [`0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a`](https://testnet.arcscan.app/address/0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a)
* **Decimals:** 6

## Crosschain

The contracts below enable crosschain interoperability between Arc and other
blockchains through Circle's
[Cross-Chain Transfer Protocol](https://developers.circle.com/cctp) (CCTP) and
[Gateway](https://developers.circle.com/gateway). CCTP handles crosschain
message passing and stablecoin transfers, while Gateway provides
chain-abstracted USDC balances for seamless liquidity movement.

### CCTP

| Contract                 | Domain | Address                                                                                                                        |
| :----------------------- | :----- | :----------------------------------------------------------------------------------------------------------------------------- |
| **TokenMessengerV2**     | 26     | [`0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA`](https://testnet.arcscan.app/address/0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA) |
| **MessageTransmitterV2** | 26     | [`0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275`](https://testnet.arcscan.app/address/0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275) |
| **TokenMinterV2**        | 26     | [`0xb43db544E2c27092c107639Ad201b3dEfAbcF192`](https://testnet.arcscan.app/address/0xb43db544E2c27092c107639Ad201b3dEfAbcF192) |
| **MessageV2**            | 26     | [`0xbaC0179bB358A8936169a63408C8481D582390C4`](https://testnet.arcscan.app/address/0xbaC0179bB358A8936169a63408C8481D582390C4) |

### Gateway

| Contract          | Domain | Address                                                                                                                        |
| :---------------- | :----- | :----------------------------------------------------------------------------------------------------------------------------- |
| **GatewayWallet** | 26     | [`0x0077777d7EBA4688BDeF3E311b846F25870A19B9`](https://testnet.arcscan.app/address/0x0077777d7EBA4688BDeF3E311b846F25870A19B9) |
| **GatewayMinter** | 26     | [`0x0022222ABE238Cc2C7Bb1f21003F0a260052475B`](https://testnet.arcscan.app/address/0x0022222ABE238Cc2C7Bb1f21003F0a260052475B) |

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Stable Fee Design

Arc's stable fee design eliminates the volatility of gas costs and ensures
predictable, auditable transaction fees. As a developer, you benefit from fees
denominated in USDC, a protocol-level smoothing mechanism, and flexible
paymaster services.

<Tip>
  On Arc, the base fee is designed to remain around one cent (≈ \$0.01) per
  transaction on average. This target embodies Arc's guiding principle of *"1
  cent, 1 second, 1 click"*, making onchain finance as fast, simple, and
  affordable as the internet itself.
</Tip>

## USDC as unit of account

Arc uses USDC as the native gas token instead of a volatile cryptocurrency. This
eliminates the need to manage token price swings and simplifies accounting.

On most blockchains, you pay gas in a volatile token (for example, ETH on
Ethereum). That means the real cost in dollars can fluctuate based on token
price and network demand. On Arc, the gas unit is pegged to USDC, which is
designed to stay stable at 1 USD.

As a result:

* You can estimate fees in advance in dollar terms.
* You don't need to hold volatile tokens just to pay gas.
* Accounting and treasury processes are simpler, because the unit of value you
  transfer and the unit you pay in are the same.

For example, if a transaction requires `g` gas units, the fee is:

```ini  theme={null}
fee = g × base_fee_in_USDC
```

The base fee is set in USDC, so you avoid the market volatility of a token-based
gas fee. The only variable is block space demand, which Arc mitigates using a
smoothing mechanism.

## Fee smoothing mechanism

Arc's fee market builds on Ethereum's EIP-1559 but changes how the base fee
adjusts. Instead of recalculating fees every block, Arc uses an exponentially
weighted moving average (EWMA) of block utilization.

This means:

* Fees adjust gradually, not abruptly.
* Short-term demand spikes have less impact.
* Base fees remain bounded, keeping costs low and predictable.

For developers, this means you don't need complex fee estimation logic. You can
expect stable base fees over time, even under varying network load.

## Stablecoin fee payments

Arc plans to expand how transaction fees can be paid by designing new mechanisms
that:

* Accept fees in stablecoins beyond USDC, including EURC, USDT, MXNB, and
  others.
* Sponsor user transactions by paying fees on their behalf.
* Programmatically define custom fee rules, such as discounts or subsidies.

<Info>
  Stablecoin fee payment support is on the roadmap and not yet available on Arc.
</Info>

This flexibility improves usability for global users who may not hold USDC
directly, and allows you to build gasless experiences or multi-currency apps
without complex workarounds.

## Developer benefits

By building on Arc's stable fee design, you gain:

* Predictable, dollar-based transaction costs: typically around 1 cent per
  transaction.
* Stable fees despite network congestion.
* Reduced integration friction for enterprise and fintech use cases.
* Flexibility to sponsor fees or accept multiple stablecoins without custom
  workarounds.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Deterministic Finality

Arc gives you deterministic, sub-second finality for every transaction. Once a
block is committed, any transaction in that block is instantly and irreversibly
final. This removes the uncertainty you may encounter on chains that rely on
probabilistic finality.

## Why deterministic finality matters

On proof-of-work or many proof-of-stake chains, transactions are considered
*final* only after multiple confirmations. Even then, there's a risk of chain
reorganizations that can undo recent blocks and transactions therein.

With Arc:

* A transaction is either unconfirmed or final.
* There's no "probably final" state.
* Once final, the transaction cannot be reversed.

This certainty allows you to build applications that demand high assurance,
especially where financial risk must be minimized and operational standards are
strict.

## Sub-second confirmation

Arc's consensus engine, Malachite, is a high-performance BFT implementation. It
finalizes blocks in less than one second.

This speed means you can:

* Process point-of-sale payments without waiting minutes for confirmation.
* Support cross-border transfers that settle instantly.
* Enable institutional trades and clearing with immediate certainty.

## Developer benefits

Deterministic finality changes how you design financial applications:

* You don't need to build retry or rollback logic for reorgs.
* You can trigger offchain effects immediately after a block is committed.
* You can meet enterprise-grade requirements for settlement assurance.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Opt-in Privacy

Arc provides opt-in privacy to enable confidential financial workflows while
preserving auditability. As a developer, you can design applications that keep
sensitive data private while still meeting compliance requirements.

<Info>Privacy features are on the roadmap and not yet available on Arc.</Info>

## Why privacy matters

Most blockchains are fully transparent. This creates problems for financial use
cases:

* **Commercial sensitivity**. Corporate treasuries, payroll, and trade finance
  cannot expose amounts publicly.
* **User protection**. Salary payments, vendor invoices, and B2B transfers may
  contain information that should not be visible to competitors or the public.
* **Compliance**. Institutions must protect customer data while also meeting
  regulatory obligations for audit and monitoring.

Arc addresses these needs with an opt-in privacy model.

## Confidential transfers

The first phase of Arc's privacy roadmap introduces confidential transfers:

1. Transaction amounts are encrypted and not visible on the public ledger.
2. Sender and receiver addresses remain visible for compatibility with analytics
   and monitoring tools.
3. Transactions still finalize onchain with the same deterministic guarantees as
   public transfers.

For developers, this means you can shield amounts without losing transparency
into participants or transaction flow.

## Selective disclosure with view keys

Arc supports view keys, which let you grant controlled read access to
confidential data:

* **Auditors and regulators** can review transaction details when required.
* **Institutions** can always monitor their own customer transactions.
* **Developers** can build apps that balance privacy and transparency by design.

This ensures you can meet regulatory obligations such as the Travel Rule while
still protecting sensitive business logic.

## Modular privacy architecture

Arc's privacy system is modular, starting with Trusted Execution Environments
(TEEs) for performance and maturity. The architecture is designed to support
additional cryptographic backends over time, including:

* **Multi-Party Computation (MPC)**. Splits secrets across multiple parties so
  no single entity can reconstruct sensitive data, increasing trust in
  collaborative workflows.
* **Fully Homomorphic Encryption (FHE)**. Lets computations run directly on
  encrypted data, ensuring privacy is preserved even during processing.
* **Zero-knowledge proofs (ZK)**. Allow one party to prove that a statement is
  true without revealing underlying data, enabling efficient compliance and
  verification.

This flexibility ensures Arc can evolve as new privacy technologies become
production-ready.

## Developer implications

With compliant privacy, you can:

* Build applications that handle sensitive financial data without exposing
  amounts onchain.
* Provide auditability and compliance by granting view keys to trusted parties.
* Plan for a future-proof privacy stack that evolves with advanced cryptography.

Arc's privacy model balances the needs of institutions, regulators, and
developers, enabling real-world financial activity onchain.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Opt-in Privacy

Arc provides opt-in privacy to enable confidential financial workflows while
preserving auditability. As a developer, you can design applications that keep
sensitive data private while still meeting compliance requirements.

<Info>Privacy features are on the roadmap and not yet available on Arc.</Info>

## Why privacy matters

Most blockchains are fully transparent. This creates problems for financial use
cases:

* **Commercial sensitivity**. Corporate treasuries, payroll, and trade finance
  cannot expose amounts publicly.
* **User protection**. Salary payments, vendor invoices, and B2B transfers may
  contain information that should not be visible to competitors or the public.
* **Compliance**. Institutions must protect customer data while also meeting
  regulatory obligations for audit and monitoring.

Arc addresses these needs with an opt-in privacy model.

## Confidential transfers

The first phase of Arc's privacy roadmap introduces confidential transfers:

1. Transaction amounts are encrypted and not visible on the public ledger.
2. Sender and receiver addresses remain visible for compatibility with analytics
   and monitoring tools.
3. Transactions still finalize onchain with the same deterministic guarantees as
   public transfers.

For developers, this means you can shield amounts without losing transparency
into participants or transaction flow.

## Selective disclosure with view keys

Arc supports view keys, which let you grant controlled read access to
confidential data:

* **Auditors and regulators** can review transaction details when required.
* **Institutions** can always monitor their own customer transactions.
* **Developers** can build apps that balance privacy and transparency by design.

This ensures you can meet regulatory obligations such as the Travel Rule while
still protecting sensitive business logic.

## Modular privacy architecture

Arc's privacy system is modular, starting with Trusted Execution Environments
(TEEs) for performance and maturity. The architecture is designed to support
additional cryptographic backends over time, including:

* **Multi-Party Computation (MPC)**. Splits secrets across multiple parties so
  no single entity can reconstruct sensitive data, increasing trust in
  collaborative workflows.
* **Fully Homomorphic Encryption (FHE)**. Lets computations run directly on
  encrypted data, ensuring privacy is preserved even during processing.
* **Zero-knowledge proofs (ZK)**. Allow one party to prove that a statement is
  true without revealing underlying data, enabling efficient compliance and
  verification.

This flexibility ensures Arc can evolve as new privacy technologies become
production-ready.

## Developer implications

With compliant privacy, you can:

* Build applications that handle sensitive financial data without exposing
  amounts onchain.
* Provide auditability and compliance by granting view keys to trusted parties.
* Plan for a future-proof privacy stack that evolves with advanced cryptography.

Arc's privacy model balances the needs of institutions, regulators, and
developers, enabling real-world financial activity onchain.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# System Overview

Arc's architecture is composed of two core components: the **Consensus layer**
and the **Execution layer**. Together, they provide deterministic finality,
stable transaction fees, programmable privacy, and financial primitives
purpose-built for stablecoin-native applications.

## Consensus layer

Arc runs on **Malachite**, a high-performance implementation of the Tendermint
Byzantine Fault Tolerant (BFT) protocol. Malachite ensures:

* **Deterministic finality:** Blocks finalize in less than one second.
* **Irreversibility:** Transactions cannot be reorganized or rolled back once
  committed.
* **Resilience:** Validators commit blocks under a Proof-of-Authority model.

The Consensus layer orders and finalizes transactions securely, providing
institutional-grade guarantees for reliability and performance.

## Execution layer

Arc's Execution layer is built on **Reth**, a Rust implementation of the
Ethereum execution layer. It maintains the blockchain ledger and state, and
extends it with components optimized for stablecoin finance:

* **Ledger and State:** Stores accounts, balances, smart contracts, and
  transaction history.
* **Fee Manager:** Stabilizes and smooths fees using USDC as the unit of
  account.
* **Privacy Module:** Provides confidential transfers and selective disclosure
  via view keys.
* **Stablecoin Services:** Powers multi-currency payments, FX conversions, and
  programmatic settlement across supported stablecoins.

By combining these components, the Execution layer provides a familiar
EVM-compatible environment with stablecoin-native extensions built in.

## System architecture diagram

The diagram below shows Arc's architecture at a high level.

```mermaid  theme={null}
%%{init: {"flowchart": {"curve": "basis"}} }%%
flowchart TB
  subgraph Consensus["Consensus layer (Malachite)"]
    C["Consensus Process<br/>(Ordering & Finality)"]
  end

  subgraph Execution["Execution layer (Reth)"]
    L["Ledger & State"]
    F["Fee Manager"]
    P["Privacy Module"]
    S["Stablecoin<br/>Services"]
  end

  C --> L
  L --> F
  L --> P
  L --> S
```

The **Consensus layer** determines the order of transactions and finalizes
blocks. The **Execution layer** applies those transactions to the ledger and
processes them through its internal modules.

## Developer benefits

By understanding Arc's system architecture, you can:

* Trust that your transactions finalize instantly and irreversibly.
* Build on a familiar EVM-compatible stack (Reth) with stablecoin-native
  extensions.
* Leverage built-in financial components like Fee Manager, Privacy, FX, and
  paying in other stablecoins without needing external workarounds.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Consensus Layer

Arc's consensus protocol provides deterministic finality in under one second. It
is built on Malachite, a high-performance implementation of the Tendermint
Byzantine Fault Tolerant (BFT) protocol, and uses a Proof-of-Authority (PoA)
validator set.

As a developer, you don't interact with consensus directly, but it defines the
guarantees you can rely on when building payment, trading, or settlement
applications.

## Core properties

Arc consensus is designed for institutional-grade performance and trust:

* **Deterministic finality:** A transaction is either unconfirmed or final. Once
  finalized, it cannot be reversed or reorganized.
* **Low latency:** Blocks finalize in less than one second under normal
  conditions.
* **High throughput:** Benchmarks show 3,000+ TPS with 20 validators and
  sub-second latency. Smaller validator sets can reach 10,000+ TPS.
* **Validator accountability:** Validators are regulated institutions with
  operational and compliance obligations.
* **Optimistic responsiveness:** The Tendermint protocol implemented by
  Malachite ensures block production and transaction confirmation proceeds as
  fast as the network permits, with no extra timeouts or artificial delays.

## Proof-of-Authority validator set

Arc uses a **permissioned Proof-of-Authority (PoA)** model.

* **Validators** are selected, known institutions with reputations, compliance
  requirements, and operational guarantees (such as uptime SLAs and SOC 2
  certification).
* **Geographic distribution** ensures resilience. Validators run across multiple
  global regions.
* **Block production** is rotated among validators to ensure fairness and
  liveness.

This design provides stronger assurances for regulated finance by replacing
anonymous economic incentives with institutional accountability.

## How Tendermint consensus works in Malachite

To order and finalize transactions, Arc uses the Tendermint BFT consensus
protocol, implemented in the Malachite consensus layer.

At a higher level, Tendermint works as follows:

1. **Propose**

   * One validator is chosen as proposer for a round.
   * The proposer bundles transactions into a block and broadcasts it.

2. **Pre-vote**

   * Validators broadcast votes indicating whether they consider the block
     valid.

3. **Pre-commit**

   * Validators broadcast a second round of votes.
   * If more than two-thirds of validators pre-commit to the same block, it is
     locked in.

4. **Commit**
   * The block is finalized and appended to the chain.
   * Transactions inside the block are now irreversible.

This two-phase voting process ensures consensus safety: two conflicting blocks
cannot both be finalized. As a result, block reorganizations are impossible, and
each block is finalized quickly and deterministically. The diagram below
illustrates the high-level concept behind this process.

```mermaid  theme={null}
sequenceDiagram
    participant P as Proposer (Validator)
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3

    Note over P,V3: Arc Consensus (Malachite BFT)

    P->>V1: 1. Propose block
    P->>V2: 1. Propose block
    P->>V3: 1. Propose block

    V1->>P: 2. Pre-vote (block valid)
    V2->>P: 2. Pre-vote (block valid)
    V3->>P: 2. Pre-vote (block valid)

    V1->>P: 3. Pre-commit (confirm vote)
    V2->>P: 3. Pre-commit (confirm vote)
    V3->>P: 3. Pre-commit (confirm vote)

    Note over P,V3: ≥2/3 of validators agree

    P->>V1: 4. Commit block
    P->>V2: 4. Commit block
    P->>V3: 4. Commit block

    Note over P,V3: Block is final (<1s)
```

## Deterministic finality

Unlike probabilistic models (like proof-of-work), Arc provides certainty about
finality.

* Once a block is finalized, it cannot be reverted without collusion of at least
  two-thirds of validators.
* There is no need for developers to wait for multiple confirmations.
* Applications can release funds or complete trades immediately after
  confirmation.

For developers, this reduces complexity since you don't need rollback logic, and
you can provide users with instant settlement guarantees.

## Performance characteristics

Arc is engineered for low latency and high throughput. In testnet environments,
you can expect performance characteristics similar to the following:

* **3,000 TPS** with 20 globally distributed validators.
* **\<350 ms** finality under benchmark conditions.
* **>10,000 TPS** with reduced validator counts (for example, 4 validators).
* **Future roadmap** includes multi-proposer support (see below), which can
  increase throughput by \~10X, and consensus optimizations that can cut latency
  by \~30%.

These metrics make Arc suitable for high-frequency payments, trading, and
settlement systems.

## Multi-proposer

The Malachite roadmap includes a planned upgrade called multi-proposer. This
feature allows multiple validators in the network to propose blocks in parallel,
rather than sequentially. By enabling concurrent block proposals, multi-proposer
can significantly increase network throughput and improve overall scalability.

## Security guarantees

Arc combines protocol-level safety with institutional safeguards:

* **Safety:** With \<1/3 faulty validators, consensus guarantees no conflicting
  blocks can be finalized.
* **Liveness:** The system continues to make progress as long as ≥2/3 of
  validators are online and honest.
* **Accountability:** Validators are regulated institutions with compliance
  obligations, making malicious behavior costly in the real world.
* **Resilience:** Geographic distribution reduces correlated downtime and attack
  risk.

## Developer implications

For developers, consensus guarantees that:

* Your transactions settle instantly and irreversibly.
* You don't need to design around chain reorganizations or probabilistic
  confirmations.
* Arc can handle institutional workloads with high TPS and low latency.
* Validator accountability ensures the network remains secure and compliant,
  even at scale.

## Roadmap

Malachite continues to evolve:

* **Multi-proposer support:** Multiple proposers per height increase overall
  throughput.
* **Latency optimizations:** New protocol variant reduces consensus rounds from
  three to two.
* **Permissioned Proof-of-Stake transition:** Over time, Arc may evolve from PoA
  to a permissioned PoS model, allowing broader validator participation while
  maintaining compliance.

These upgrades will further strengthen Arc as infrastructure for global
financial applications.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Execution Layer

Arc's execution layer is based on **Reth**, a Rust implementation of the
Ethereum execution client. This layer maintains the ledger and blockchain state,
executes transactions, and extends the EVM with Arc-specific modules for
stablecoin-native finance.

As a developer, you don't interact directly with the execution layer internals,
but understanding how it works helps you design apps that rely on Arc's
predictable fees, privacy, and financial primitives.

## Core responsibilities

The Execution layer has three primary jobs:

1. **Maintain the ledger and application state**

   * Tracks accounts, balances, and smart contracts.
   * Stores contract code and persistent state variables.
   * Records every transaction and resulting state change.

2. **Execute transactions**

   * Applies EVM logic for smart contracts and transfers.
   * Deducts gas costs using the Fee Manager.
   * Calls Arc modules (Privacy, Stablecoin Services) where applicable.

3. **Validate results**
   * Ensures transactions are valid before they can be finalized by consensus.
   * Rejects invalid transactions (for example, insufficient funds or failed
     contract logic).
   * Produces a state root hash, which consensus finalizes.

## Arc-specific modules

Arc extends the base Ethereum execution model with the following modules:

* **Fee Manager:** Stabilizes fees by using USDC as the unit of account and
  smoothing fee changes.
* **Privacy Module:** Enables confidential transfers with encrypted amounts and
  selective disclosure through view keys.
  <Info>The Privacy Module is planned and not yet available on Arc.</Info>
* **Stablecoin Services:** Provide core stablecoin-native features such as
  cross-currency settlement, paymaster-style sponsored transactions, and
  multi-stablecoin gas payments.
  <Info>Stablecoin Services are planned and not yet available on Arc.</Info>

These modules are integrated into the execution pipeline, so you can rely on
them without building custom extensions.

## How Reth works

Reth, like other Ethereum execution clients, follows a structured pipeline:

1. **Transaction pool:** Holds pending transactions waiting to be included in a
   block.
2. **Block execution:** Applies transactions sequentially to the current state,
   updating balances, contract storage, and logs.
3. **Gas accounting:** Deducts gas fees through Arc's Fee Manager.
4. **Module calls:** Routes to Privacy or Stablecoin Services logic as required.
5. **State root:** Produces a Merkle root of the updated state.

Reth is written in Rust, which provides performance, safety, and modularity. Arc
leverages this foundation to extend the execution layer with stablecoin-native
features.

## Execution diagram

The diagram below shows the flow of a transaction through the Execution layer.

```mermaid  theme={null}
%%{init: {"flowchart": {"curve": "basis"}} }%%
flowchart LR
  subgraph EE["Execution layer (Reth)"]
    T["Tx Pool"]
    E["EVM Execution<br/>(Smart contracts & transfers)"]
    FM["Fee Manager<br/>(USDC-based fees)"]
    PM["Privacy Module<br/>(Confidential transfers)"]
    SS["Stablecoin Services<br/>(FX and multi-stablecoin fees)"]
    L["Ledger & State<br/>(Accounts, balances, contracts)"]
    SR["State Root<br/>(Merkle hash)"]
  end

  T --> E
  E --> FM
  E --> PM
  E --> SS
  FM --> L
  PM --> L
  SS --> L
  L --> SR
```

## Developer benefits

For developers, the Execution layer means:

* You build on a familiar EVM-compatible platform.
* Fees, privacy, and multi-stablecoin settlement are native features, not
  bolt-ons.
* Transactions are validated and applied consistently, following the order
  finalized by the consensus layer.
* The underlying ledger and state are managed efficiently by Reth, written in
  Rust for performance and reliability.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# EVM Compatibility

Arc is compatible with the Ethereum Virtual Machine (EVM). Developers can deploy
and interact with smart contracts using the same tools, languages, and
frameworks they use on Ethereum such as Solidity, Foundry, and Hardhat.

While the execution environment mirrors Ethereum's, Arc introduces a few key
differences:

* **USDC as native gas:** All fees and balances are denominated in USDC, not
  ETH.
* **Deterministic finality:** Transactions finalize instantly and cannot be
  reversed.
* **Simplified block times:** Blocks are timestamped by real time, not epochs or
  slots.
* **Stable fee model:** Gas prices are smoothed for predictability.
* **Permissioned validators:** Arc uses a BFT consensus model (Malachite) for
  speed and reliability.

These changes make Arc predictable and stable while preserving EVM
compatibility.

## ERC20 interface

Arc uses USDC as its native network token. Native balances behave like ETH on
Ethereum and are represented with 18 decimals. An optional ERC20 interface is
also available: see
[USDC contract address](/arc/references/contract-addresses#USDC). This ERC20
provides the same capability as USDC on other EVM networks, such as ERC20
allowances and `transferFrom`, and uses **6 decimals** to match the standard
USDC representation.

This has two important effects:

1. Tiny USDC amounts (less than 1 x 10⁻⁶ USDC) cannot be transferred using the
   ERC20 interface.
2. Protocols that hold USDC as an ERC20 automatically hold equivalent native
   balances. No additional Solidity changes are required (for example, `payable`
   or `receive` functions) as ERC20 transfers are directly reflected in the
   native balance.

## EVM differences

Arc targets the **Prague** EVM hard fork with minor differences in execution and
consensus behavior.\
The table below summarizes key distinctions from Ethereum mainnet.

| Area                           | Ethereum                              | Arc                                                                                                 |
| ------------------------------ | ------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **Native token**               | ETH, volatile pricing                 | USDC, stable pricing with 18 decimals; used as gas                                                  |
| **Fee market**                 | EIP-1559 base fee per block           | Fee smoothing with moving average; stable, bounded base fee, inspired by EIP-1559                   |
| **Finality**                   | Probabilistic (≈12–15 min for safety) | Deterministic and instant (\<1 s)                                                                   |
| **Consensus**                  | Proof-of-Stake (slot/epoch model)     | Malachite (Tendermint-based) BFT with permissioned validators                                       |
| **Block timestamps**           | Derived from slots and epochs         | Wall-clock time from proposer with second-level granularity; sub-second blocks may share timestamps |
| **`SELFDESTRUCT`**             | Allowed with value transfers to self  | Not allowed during deployment to prevent burning native tokens                                      |
| **`PARENT_BEACON_BLOCK_ROOT`** | Root of parent beacon block (SSZ)     | Hash of parent execution payload header (`keccak256(RLP(header))`); no beacon chain                 |
| **`PREV_RANDAO`**              | Randomness mix of proposer reveals    | Always `0`; not used for randomness                                                                 |
| **USDC blocklist handling**    | Runtime revert on transfer            | Pre-block inclusion check when possible; reverts or blocks as described below                       |
| **EIP-4844 blobs**             | Supported post-Dencun                 | Currently disabled                                                                                  |

### USDC blocklist revert handling

Arc enforces USDC blocklists both pre- and post-execution:

* **Pre-mempool check:** If the sender is blocklisted, the transaction is
  rejected before entering the mempool. No fees are collected.
* **Post-mempool check:** If the address becomes blocklisted after acceptance
  but before execution, the transaction reverts at runtime and consumes gas.
* **Runtime transfer check:** If a valid transaction attempts to move USDC to or
  from a blocklisted address, only that operation reverts. Fees are still
  collected.

## Developer impact

For most use cases, Ethereum-based tooling and smart contracts will work on Arc
without modification. However, developers should note a few practical
differences:

* **Gas denomination:** All values are in USDC. When using libraries like
  `ethers.js` or `viem`, display and accounting logic should format values in
  USD terms, not ETH.
* **Timestamps:** Multiple blocks may share the same timestamp; avoid assuming
  strictly increasing values for onchain time comparisons.
* **Randomness:** `block.prevrandao` is always zero. Do not use it as a source
  of randomness; use an external oracle or verifiable randomness function (VRF)
  instead.
* **Finality:** Transactions finalize immediately after inclusion. Offchain
  systems can safely act on events after a single confirmation: no additional
  block waiting is required.
* **SELFDESTRUCT restrictions:** Contracts that self-destruct during deployment
  will revert if they attempt to send USDC value to themselves.

These differences are designed to make Arc's execution environment predictable
and stable while remaining interoperable with the Ethereum developer ecosystem.

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Account Abstraction

Account Abstraction (AA) providers enable developers to build smart contract
wallets that can initiate and validate transactions without relying on
externally owned accounts (EOAs).

## Providers

These platforms and SDKs enable Account Abstraction on Arc, offering tools for
smart account creation, session management, paymaster integration, and
transaction sponsorship.

| Provider                                                     | Description                                                                                                                                                                                                                                |
| :----------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [**Biconomy**](https://www.biconomy.io)                      | Provides an Account Abstraction toolkit for dapps and wallets, offering modular smart accounts, paymasters, and bundlers as a service to simplify the user experience.                                                                     |
| [**Blockradar**](https://blockradar.co)                      | Provides infrastructure and APIs for smart account management and transaction bundling, enabling developers to build scalable AA flows with minimal setup.                                                                                 |
| [**Circle Wallets**](https://developers.circle.com/wallets)  | Provides an end-to-end platform for creating and managing secure Arc wallets and cryptographic keys. Circle Wallets supports stablecoins, fungible tokens, and NFTs, and is fully compatible with ERC-20, ERC-721, and ERC-1155 standards. |
| [**Crossmint**](https://www.crossmint.com)                   | Offers wallet-as-a-service and AA capabilities to onboard users with email or OAuth-based accounts.                                                                                                                                        |
| [**Dynamic**](https://www.dynamic.xyz)                       | Identity and wallet orchestration platform with native ERC-4337 support, enabling passkey wallets and flexible signer management.                                                                                                          |
| [**Para**](https://getpara.com)                              | A comprehensive wallet and authentication suite for fintech and crypto applications, enabling flexible wallet management and transaction signing.                                                                                          |
| [**Pimlico**](https://pimlico.io)                            | Bundler and paymaster infrastructure for ERC-4337 smart accounts, offering sponsored transactions and reliable relay services.                                                                                                             |
| [**Thirdweb**](https://portal.thirdweb.com/wallets)          | Full-stack toolkit with built-in AA support, SDKs, and a managed smart wallet layer for developers.                                                                                                                                        |
| [**Turnkey**](https://docs.turnkey.com/reference/aa-wallets) | Programmable key management API enabling secure, policy-based smart account control and AA wallet creation.                                                                                                                                |
| [**Zerodev**](https://zerodev.app)                           | Developer SDK for deploying and managing ERC-4337 smart accounts, with built-in session key and bundler support.                                                                                                                           |

<Info>
  Arc's Account Abstraction ecosystem is modular: developers can mix SDKs,
  paymasters, and bundlers from multiple providers to design their smart account
  architecture based on their needs.
</Info>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Block Explorers

Block explorers let you view, verify, and analyze transactions, addresses,
contracts, and other onchain data on Arc. They provide developer and user
interfaces for querying block details, inspecting smart contract interactions,
and tracking USDC-based fee activity.

## Providers

| Provider                                     | Description                                                                                                                                                                                        |
| :------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [**Blockscout**](https://www.blockscout.com) | Open-source explorer offering contract verification, token tracking, and API endpoints for custom integrations. A Blockscout explorer is available for [Arc Testnet](https://testnet.arcscan.app). |

<Info>
  Arc's explorers are continuously expanding: developers can use standard
  Etherscan-compatible APIs to query data and verify contracts seamlessly.
</Info>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Compliance

Compliance vendors provide risk monitoring, wallet screening, and transaction
analytics tools that help developers and institutions meet regulatory
requirements when building on Arc. These services integrate directly into
payment flows, wallet infrastructure, and smart contracts to enhance security
and transparency.

## Providers

| Provider                                | Description                                                                                                                                                                |
| :-------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [**Elliptic**](https://www.elliptic.co) | Offers blockchain analytics and transaction monitoring APIs to identify illicit activity, assess risk exposure, and ensure compliance with AML and sanctions requirements. |
| [**TRM Labs**](https://www.trmlabs.com) | Provides risk intelligence, wallet screening, and real-time monitoring tools to detect fraud, money laundering, and other suspicious behavior across Arc transactions.     |

<Info>
  Arc's compliance ecosystem continues to expand: developers can integrate
  analytics, screening, and monitoring tools from leading vendors to meet
  jurisdictional requirements and strengthen trust in their applications.
</Info>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Data Indexers

Data indexers make it easy to query and analyze onchain data from Arc. They
provide APIs and SDKs for tracking smart contract events, balances, and
historical state changes without running your own indexing infrastructure.

## Providers

| Provider                              | Description                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [**Envio**](https://envio.dev)        | Developer-first indexing framework for event-driven data and GraphQL APIs on Arc. <br />   • [**HyperIndex**](https://envio.dev/#hyperindex): Build production-ready APIs from Arc data in minutes. <br />   • Stream live blockchain events with minimal latency.                                                                                                                                                       |
| [**Goldsky**](https://goldsky.com)    | Managed subgraph and data pipeline platform for Arc contracts. <br />   • [**Subgraphs**](https://goldsky.com/products/subgraphs): Autoscaling query engine with 99.9%+ uptime and up to 6× faster performance. <br />   • [**Mirror**](https://goldsky.com/products/mirror): Stream Arc onchain data to your database with sub-second latency for combined on/offchain queries.                                         |
| [**The Graph**](https://thegraph.com) | Decentralized indexing protocol for querying Arc's onchain data through APIs. <br />   • [**Sub-graphs**](https://thegraph.com/docs/en/developing/creating-a-subgraph/): Query smart contract data on Arc through multiple indexers, reducing single points of failure. <br />   • [**Graph Explorer**](https://thegraph.com/explorer): Discover and reuse subgraphs published by other developers on The Graph Network. |
| [**Thirdweb**](https://thirdweb.com)  | Open-source blockchain data tooling. View and contribute to its source code on GitHub. <br />   • [**Insight**](https://portal.thirdweb.com/insight): Retrieve Arc blockchain data, enrich it with metadata, and transform it using custom logic.                                                                                                                                                                        |

<Info>
  Data indexers integrate with Arc's EVM-compatible environment: allowing
  developers to query, transform, and combine onchain data using familiar APIs
  and tools.
</Info>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
# Node Providers

Node providers offer RPC endpoints and infrastructure that allow developers to
connect to the Arc network, submit transactions, and query blockchain data.
These providers deliver reliable, scalable access to Arc's EVM-compatible
environment, supporting both HTTP and WebSocket connections for testnet and
mainnet environments.

## Providers

| Provider                                                     | Description                                                                                                                 |
| :----------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- |
| [**Alchemy**](https://www.alchemy.com/arc)                   | Developer platform providing scalable access to EVM networks with enhanced APIs, monitoring, and debugging tools.           |
| [**Blockdaemon**](https://www.blockdaemon.com/protocols/arc) | Institutional-grade node provider offering secure and compliant infrastructure for Arc and other EVM chains.                |
| [**dRPC**](https://drpc.org/chainlist/arc-testnet-rpc)       | Decentralized RPC aggregator providing high-speed, load-balanced access to Arc nodes through a multi-provider architecture. |
| [**QuickNode**](https://www.quicknode.com/chains/arc)        | High-performance blockchain infrastructure offering global endpoints and APIs for developers.                               |

<Info>
  You can connect directly to Arc's public RPC endpoint or through any of these
  infrastructure partners using your preferred SDK or web3 client.
</Info>

<Note>
  By using the Arc Network Testnet, you agree to the [Terms of Service](/terms)
  and [Privacy Policy](https://www.circle.com/legal/privacy-policy).
</Note>
